#!/usr/bin/env bash

### Version 1.0.0
### Created by Erik Berglund
### https://github.com/erikberglund

#//////////////////////////////////////////////////////////////////////////////////////////////////
###
### DESCRIPTION
###
#//////////////////////////////////////////////////////////////////////////////////////////////////

# Loops through all .dmg files (expects DeployStudio installation dmg) in passed path or working directory.
# Extract DSCore binary and does a binary grep to see if it contains a string.

#//////////////////////////////////////////////////////////////////////////////////////////////////
###
### FUNCIONS
###
#//////////////////////////////////////////////////////////////////////////////////////////////////

parse_opts() {
	while getopts "o:p:" opt; do
		case ${opt} in
			o) output_directory="${OPTARG}" ;;
			p) input_directory="${OPTARG}" ;;
			\?) printf "%s\n" "Invalid option: -${OPTARG}" >&2; exit 1;;
			:) printf "%s\n" "Option -${OPTARG} requires an argument." >&2; exit 1;;
		esac
	done
	
	# Check 'input_directory' options, set to '/Applications' if non was passed.
	if [[ -z ${input_directory} ]]; then
		printf "%s\n" "No input directory specified, will use /Applications for input..."
		input_directory="/Applications"
	elif ! [[ -d ${input_directory} ]]; then
		error "${input_directory} is not a directory"
	fi
	
	# Add all OS X Installer Applications passing test to array 'osx_installers'
	for app in "${input_directory}"/*\.app/; do
		if [[ -f "${app}/Contents/Info.plist" ]] && [[ "$( /usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "${app}/Contents/Info.plist" )" =~  ^com.apple.InstallAssistant.* ]]; then
			osx_installers+=( "${app%/}" )
		fi
	done
	
	# Check 'output_directory' options, set to 'PWD' if none was passed.
	if [[ -z ${output_directory} ]]; then
		printf "%s\n" "No output directory specified, will use working directory for ouput..."
		output_directory="${PWD}"
	elif ! [[ -d ${output_directory} ]]; then
		error "${output_directory} is not a directory"
	fi
	
	# Check if current user has write capabilities for output_directory
	if ! [[ -w ${output_directory} ]]; then
		error "User: ${USER} doesn't have write permissions for output folder: ${output_directory}"	
	fi
}

usage() { 
	printf "%s\n" "Usage: ./${0##*/} [options] <argv>..."
	printf "%s\n" "Options:"
	printf "  %s\t%s\n" "-o" "Output directory"
	printf "  %s\t%s\n" "-p" "(Optional) Input directory"
	printf "\n"
}

error() {
	printf "%s\n" "${1}, exiting script..." >&2; exit 1
}

#//////////////////////////////////////////////////////////////////////////////////////////////////
###
### MAIN SCRIPT
###
#//////////////////////////////////////////////////////////////////////////////////////////////////

# Stop globbing from printing itself if there are no matches.
shopt -s nullglob

# Parse passed arguments.
parse_opts "${@}"

# Loop through all installers and archive them to output folder
for osx_installer in "${osx_installers[@]}"; do
	
	# Verify InstallESD.dmg exists
	if [[ ! -f ${osx_installer}/Contents/SharedSupport/InstallESD.dmg ]]; then
		printf "%s\n" "No InstallESD" >&2
		continue
	fi
	
	# Get installer name
	installer_name=$( /usr/libexec/PlistBuddy -c "Print :CFBundleDisplayName" "${osx_installer}/Contents/Info.plist" )
	
	# If InstallESD.dmg is already mounted, exit script and print it's current mountpoint.
	install_esd_mountpoint=$( hdiutil info -plist | xpath "/plist/dict/key[.='images']/following-sibling::array/dict/key[.='image-path']/following-sibling::string[1][contains(., \"${osx_installer}/Contents/SharedSupport/InstallESD.dmg\")]/../key[.='system-entities']/following-sibling::array/dict/key[.='mount-point']/following-sibling::string/text()" 2>/dev/null )
	if [[ -n ${install_esd_mountpoint} ]]; then
		printf "%s\n" "InstallESD is already mounted at: ${install_esd_mountpoint}" >&2
		continue
	fi
	
	# Create mountpoint for InstallESD.dmg
	install_esd_mountpoint=$( mktemp -d /private/tmp/dmg.XXXXX ) || error "Unable to create InstallESD mountpoint"
	
	# Attach current dmg at 'install_esd_mountpoint'
	if hdiutil attach "${osx_installer}/Contents/SharedSupport/InstallESD.dmg" -noverify -nobrowse -readonly -owners on -mountpoint "${install_esd_mountpoint}" -quiet; then
				
		# Verify SystemVersion.plist exists
		if [[ ! -f ${install_esd_mountpoint}/System/Library/CoreServices/SystemVersion.plist ]]; then
			printf "%s\n" "Invalid InstallESD.dmg" >&2
			hdiutil detach "${install_esd_mountpoint}" -force -quiet || printf "%s\n" "Detaching image failed" >&2
			continue
		fi
		
		# Get installer os build and version
		installer_os_version=$( /usr/libexec/PlistBuddy -c "Print :ProductUserVisibleVersion" "${install_esd_mountpoint}/System/Library/CoreServices/SystemVersion.plist" )
		installer_os_build_version=$( /usr/libexec/PlistBuddy -c "Print :ProductBuildVersion" "${install_esd_mountpoint}/System/Library/CoreServices/SystemVersion.plist" )
		
		# Detach InstallESD
		hdiutil detach "${install_esd_mountpoint}" -force -quiet || printf "%s\n" "Detaching image failed" >&2
	else
		error "Attach image failed"
	fi
	
	# Remove temporary mountpoint
	rm -rf "${install_esd_mountpoint}"
	
	# Create name for dmg
	name=$( sed 's/\ //g' <<< "${installer_name}_${installer_os_version}_${installer_os_build_version}" )
	
	# Check if target dmg already exist in selected ouptut directory
	if [[ -f ${output_directory}/${name} ]]; then
		printf "%s\n" "${output_directory}/${name} already exist, skipping..." >&2
		continue	
	fi
	
	# Remove quarantine attribute if present
	xattr -d -r com.apple.quarantine "${osx_installer}" 2>&1
	
	# Create installer dmg archive
	if ! hdiutil create -srcfolder "${osx_installer}" -volname "${name}" -quiet "${name}"; then
		error "Creating installer dmg failed"
	fi
done

# Restore globbing behaviour.
shopt -u nullglob

exit 0